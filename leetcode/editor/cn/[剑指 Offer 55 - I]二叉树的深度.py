# è¾“å…¥ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ±‚è¯¥æ ‘çš„æ·±åº¦ã€‚ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ä¾æ¬¡ç»è¿‡çš„èŠ‚ç‚¹ï¼ˆå«æ ¹ã€å¶èŠ‚ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„é•¿åº¦ä¸ºæ ‘çš„æ·±åº¦ã€‚ 
# 
#  ä¾‹å¦‚ï¼š 
# 
#  ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7]ï¼Œ 
# 
#      3
#    / \
#   9  20
#     /  \
#    15   7 
# 
#  è¿”å›å®ƒçš„æœ€å¤§æ·±åº¦ 3 ã€‚ 
# 
#  
# 
#  æç¤ºï¼š 
# 
#  
#  èŠ‚ç‚¹æ€»æ•° <= 10000 
#  
# 
#  æ³¨æ„ï¼šæœ¬é¢˜ä¸ä¸»ç«™ 104 é¢˜ç›¸åŒï¼šhttps://leetcode-cn.com/problems/maximum-depth-of-binary-
# tree/ 
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 217 ğŸ‘ 0
import collections


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:

    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) +1

    def maxDepth2(self, root: TreeNode) -> int:
        if not root:
            return 0
        deque = collections.deque([root])
        depth = 0
        while deque:
            depth += 1
            size = len(deque)
            for _ in range(size):
                node = deque.popleft()
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)

        return depth


# leetcode submit region end(Prohibit modification and deletion)
