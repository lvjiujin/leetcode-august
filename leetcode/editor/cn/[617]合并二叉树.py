# ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š root1 å’Œ root2 ã€‚ 
# 
#  æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å 
# ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œä¸ä¸º null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚ 
# 
#  è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚ 
# 
#  æ³¨æ„: åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚ 
# 
#  
# 
#  ç¤ºä¾‹ 1ï¼š 
#  
#  
# è¾“å…¥ï¼šroot1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
# è¾“å‡ºï¼š[3,4,5,5,4,null,7]
#  
# 
#  ç¤ºä¾‹ 2ï¼š 
# 
#  
# è¾“å…¥ï¼šroot1 = [1], root2 = [1,2]
# è¾“å‡ºï¼š[2,2]
#  
# 
#  
# 
#  æç¤ºï¼š 
# 
#  
#  ä¸¤æ£µæ ‘ä¸­çš„èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [0, 2000] å†… 
#  -10â´ <= Node.val <= 10â´ 
#  
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 1090 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        # if not root1 and not root2:
        #     return None
        # if not root1:
        #     return root2
        # if not root2:
        #     return root1
        # root = TreeNode(root1.val + root2.val)
        # root.left = self.mergeTrees(root1.left, root2.left)
        # root.right = self.mergeTrees(root1.right, root2.right)
        # return root

        if not root1:
            return root2
        if not root2:
            return root1
        import collections
        merged = TreeNode(root1.val + root2.val)
        queue = collections.deque([merged])
        queue1 = collections.deque([root1])
        queue2 = collections.deque([root2])

        while queue1 and queue2:
            node = queue.popleft()
            node1 = queue1.popleft()
            node2 = queue2.popleft()
            left1, right1 = node1.left, node1.right
            left2, right2 = node2.left, node2.right
            if left1 or left2:
                if left1 and left2:
                    left = TreeNode(left1.val + left2.val)
                    node.left = left
                    queue.append(left)
                    queue1.append(left1)
                    queue2.append(left2)
                elif left1:
                    node.left = left1
                elif left2:
                    node.left = left2
            if right1 or right2:
                if right1 and right2:
                    right = TreeNode(right1.val + right2.val)
                    node.right = right
                    queue.append(right)
                    queue1.append(right1)
                    queue2.append(right2)
                elif right1:
                    node.right = right1
                elif right2:
                    node.right = right2

        return merged


# leetcode submit region end(Prohibit modification and deletion)
